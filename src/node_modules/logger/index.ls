require! {
# -------------------------------------------------------------------------- STD
	util
}



# TODO Use a proxy for on and off. When on, forward. When off, filter.

export class Logger
	~>
		@ <<< {
			# Parameters -------------------------------------------------------

			# -------------------------------------------------- Display control

			-doLog
			+turnOffOnSeparator
			outputWidth: 80

			getSeparatorWidth: -> @outputWidth
			getDelimiterWidth: -> @getSeparatorWidth! / 2

			# ---------------------------------------------------------- Strings

			sepChar: '-'
			prefixes:
				fatal: '''

					CHECK THIS:
				'''
				exception: 'Exception: '
			messages:
				fail: 'WARNING: didn\'t fail as expected'

			# ------------------------------------------------------- Exit codes

			codes:
				defaultStop: 0
				fatalCode: 1

			# ----------------------------------------------------------- Others

			inspectConfig: {depth: null, +colors, -showHidden}

			# ------------------------------------------------------- For future

			overrides: {}
			blacklist: []



			# Internal ---------------------------------------------------------

			logCount: 1
			sepCount: 1
		}



################################################################################
# Logging
################################################################################

	logString: (str) !->
		console.log str

	logstring: ::logString
	logStr: ::logString
	logstr: ::logString



################################################################################
# Serialization
################################################################################

	# stringify: -> util.inspect @clean(it), {depth: null, +colors, -showHidden}
	stringify: (object) ->
		util.inspect object, @inspectConfig

	# clean: (node) ->
	# 	switch typeof! node
	# 	| 'Object'
	# 		result = {}
	# 		for key, value of node | key not in @blacklist
	# 			overriden = @override key, value
	# 			if typeof! overriden isnt 'Function' => result[key] = @clean overriden
	# 	| 'Array' => result = [@clean .. for node]
	# 	| _ => result = node
	# 	result

	# override: (key, value) ->
	# 	if @overrides[key]? => @overrides[key] value else value



################################################################################
# Display configuration
################################################################################

	on: -> @doLog = yes
	show: ::on
	activate: ::on
	resume: ::on

	off: -> @doLog = no
	hide: ::off
	disable: ::off
	deactivate: ::off
	suspend: ::off

	toggle: -> @doLog = not @doLog



################################################################################
# Display
################################################################################

	separator: (label) !->
		# --------------------------------------------------------------- output

		prefix = if label? => " - #label" else ''
		dashes = "#{@sepChar}" * (@getSeparatorWidth! - prefix.length)

		output = """

			#{@sepCount}#prefix #dashes

		"""

		# -------------------------------------------------------------- actions

		@logString output

		@logCount = 1
		@sepCount++
		if @turnOffOnSeparator => @off!

	sep: ::separator


	delimiter: !-> if @doLog
		@logString "#{@sepChar}" * @getDelimiterWidth!

	del: ::delimiter



################################################################################
# Testing workflow
################################################################################

	log: !(value, prefix) -> if @doLog
		prefix ?= ''
		str = @stringify value
		@logString "#{@logCount}: #prefix#str"
		@logCount++

	# test: ::log

	fail: (fn) !-> if @doLog
		try
			fn!
			@log @messages.fail
		catch e
			@log e, @prefixes.exception

	fatal: (fn) !->
		@logString @prefixes.fatal
		@fail fn
		@stop @codes.fatalCode

	stop: (code = @codes.defaultStop) !->
		process.exit code



################################################################################
# Other - Methods to test factories?
################################################################################

	setFactory: (fn, context) !->
		@factoryContext = context ? @
		@factoryFunction = fn

	factory: !-> if @factoryFunction?
		@log {
			input: &0
			context: &1
			result: @factoryFunction.apply @factoryContext, &
		}
