The runner takes a set of test specifications and runs the resulting tests.


# Tests architecture

For now, we'll follow the idea of the [`logger`](../logger) module, which introduces sections of tests, and then inside each of them the tests themselves.





# Test model

A test has the following properties:

* name
* callback to run the processing giving the value
* callback to validate the result according to the expectations

> Why using callbacks?

As usual, it's more flexible, since you can do anything with them: asynchronous stuff, accessing anything, ...

> Added value for the processing callback?

It can be run safely, in isolation in a `try/catch` basically, in order to be able to test normal failing cases.

> And why one for the test validation?

Because we just provide all the output to the user: exception, output value, but also a copy of the input.

This way he can do anything.

## Validation

Of course, convenient shortcut should be provided.

If no validation callback is provided, here are the alternatives:

* `exception`: if truthy, the test will pass if an exception was raised
* `value`: if nothing else is specified, this will defined the expected value. This is the last resort, so that even if it's undefined, we will consider that it is expected that the test return a void value.

## Running

The callback definition to run the test must contain everything:

* the function
* its inputs: arguments list and the `this` value
